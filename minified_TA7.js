function findAnchorProductForm() { let e = Array.from(document.querySelectorAll('input[name="id"], select[name="id"]')); if (!e.length) return console.log("No anchors were found, revert to manual extraction"), { validNameIdElement: null, anchorProductForm: null, nameIdAnchors: [] }; let t = /product[-_]*.*[-_]*form/i, n = null, r = e.find(e => Boolean(n = findClosestRegexMatchedAncestor(e, t))); return { validNameIdElement: r, anchorProductForm: n, nameIdAnchors: e } } function findClosestRegexMatchedAncestor(e, t) { let n = e.parentElement; for (; n && n !== document.body;) { if (isElementVisible(n) && formMatchesRegex(n, t)) return n; n = n.parentElement } return null } function formMatchesRegex(e, t) { return !!e && !!e.attributes && Array.from(e.attributes).some(e => "style" !== e.name && t.test(e.value)) } function isElementVisible(e) { let t = getComputedStyle(e); return "none" !== t.display && "hidden" !== t.visibility && parseFloat(t.opacity) > 0 && null !== e.offsetParent && e.getClientRects().length > 0 } function getParentNodeForVPCSearch(e, t = null, n = !1) { let r, a; if (n) { if (!e || e === document.body) return null; a = e.parentElement } else { a = r = e.parentElement; let l = t || 4, o = 0; for (; r && r !== document.body && o < l;)a = r, r = r.parentElement, o++ } let i = null; return a && (i = a.querySelector("button[type=submit]")), { addToCartButton: i, parent: a, isBodyNext: a?.parentElement === document.body } } async function getProductData(e = !1) { let t = `${window.location.pathname}.json`, n = await fetch(t); if (!n.ok) throw Error("Failed to fetch product JSON"); let r = await n.json(); return e && console.log({ optionNamesInJSON: r.product.options.map(e => e.name) }), r.product } function getCorrectVariantPickerWithSelectors(e, t, n, r, a, l) { let o = generateOptionExtractionKeys(e, t, n, r, a, l), i = {}, s = !1; return (s = t > 1 ? o.length === e.option_wrappers.length : 1 === o.length) ? (i.selector_set = generateSelectorsfromOpexKeys(o), i.selector_data = extractFinalSelectors(i.selector_set), i.selector_set.length) ? i : null : (console.warn({ option_extraction_status: "[Failure]", optionExtractionKeys: o }), null) } function generateOptionExtractionKeys(e, t, n, r, a, l) { let o = []; return t > 1 ? o = l.fieldSetMap.map((t, n) => ({ optionAxis: a[t].values[r], ov_attribute: l.selector_yielding_ova_perFsCand[n], fs_cand: e.option_wrappers[n] })) : o.push({ optionAxis: n, ov_attribute: l.selector_yielding_ova_perFsCand[0], fs_cand: l.fieldSet }), console.log({ optionExtractionKeys: o }), o } function generateSelectorsfromOpexKeys(e) { return e.map(e => { let t = Array.from(e.ov_attribute), n = e.fs_cand, r = []; for (let a of t) { let l = new Set, o = e.optionAxis; for (let i of o) { let s = `[${a}="${CSS.escape(i)}"]`, u = n.querySelector(s); u && l.add(u) } l.size && r.push({ ov_attribute: a, selectors: l }) } let c = {}; for (let p = 0; p < r.length; p++) { let { ov_attribute: d, selectors: f } = r[p], m = !1; for (let g in c) { let h = c[g]; if (f.size === h.length && [...f].every(e => h.includes(e))) { m = !0; break } } m || (c[d] = Array.from(f)) } return c }) } function extractFinalSelectors(e) { let t = []; for (let n of e) { let r = Object.entries(n); if (1 === r.length) { let [[a, l]] = r; t.push({ value_attribute: a, selectors: l }); continue } let o = !1, i = null, s = [], u = []; for (let [c, p] of r) (o = p.some(e => isElementVisible(e.parentElement))) ? s.push({ ov_attribute: c, selectors: p }) : u.push({ ov_attribute: c, selectors: p }); i = { value_attribute: (i = s.length ? 1 === s.length ? s[0] : returnBestSelectorSet(s) : returnBestSelectorSet(u)).ov_attribute, selectors: i.selectors }, t.push(i) } return t } function returnBestSelectorSet(e) { let t = ["input", "option", "button", "a", "li", "div", "label",], n = e.map((e, t) => ({ selectorRep: e.selectors[0].tagName.toLowerCase(), inSelSetIndex: t, selProListIndex: -1 })); for (let r of n) { let a = r.selectorRep; r.selProListIndex = t.findIndex(e => e === a) } return e[n.reduce((e, t) => -1 === e.selProListIndex ? t : -1 === t.selProListIndex ? e : t.selProListIndex < e.selProListIndex ? t : e).inSelSetIndex] } function normalizeValue(e) { return e.toLowerCase().trim().normalize("NFKD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "") } function isValidVariantPicker(e, t, n, r) { let a = e.option_wrappers.reduce((e, t, n) => { let r = getComputedStyle(t), a = "none" !== r.display && "hidden" !== r.visibility && parseFloat(r.opacity) > 0 && null !== t.offsetParent && t.getClientRects().length > 0; return a && e.push(n), e }, []); if (0 === a.length) return console.log({ Control_Function: "isValidVariantPicker()", Failure: "Variant picker is fully invisible", vp_candidate: e }), null; let l = e.option_wrappers.map(e => { let t = r.filter(t => e.querySelector(`[${t}]`)); return t.length ? t : [] }); if (l.every(e => !e.length)) return console.warn({ Control_Function: "isValidVariantPicker()", Error: "Invalid vp_candidate", vp_candidate: e, ov_attributes_filtered_per_fsCand: l }), null; let o = []; if (1 === t) { let i = l[0].filter(t => { let r = `[${t}="${CSS.escape(n[0])}"]`; return e.option_wrappers[0].querySelector(r) }); return i.length > 0 ? (o.push(i), { selector_yielding_ova_perFsCand: o, fieldSet: e.option_wrappers[0] }) : null } let s = Array(t).fill(-1), u = e.option_wrappers, c = !1; for (let p = 0; p < e.option_wrappers.length; p++) { let d = u[p]; for (let f = 0; f < n.length; f++) { if (!l[p].length) { o.push([]); continue } let m = l[p]; if ((m = m.filter(e => { let t = `[${e}="${CSS.escape(n[f])}"]`; if (d.querySelector(t)) return !0 })).length > 0) { if (-1 !== s[p]) return console.log({ "isValidVariantPicker()": "1:1 mapping failed", fs_cand: u[p], vp_candidate: e }), null; if (c = !0, s[p] = f, o.push(m), isNumericString(n[f])) break } } } return c ? { selector_yielding_ova_perFsCand: o, fieldSetMap: s } : (console.warn({ Control_Function: "isValidVariantPicker()", message: "No 1:1 mapping detected", vp_candidate: e }), null) } function isNumericString(e) { return "string" == typeof e && "" !== e.trim() && !Number.isNaN(Number(e)) } function createVariantPicker(e, t) { if (!Array.isArray(e) || !e.length) return null; if (e.filter(Boolean).length < t) return console.warn({ Control_Function: "createVariantPicker()", message: "Leaf selectors count does not match active optionCount" }), null; let n = [...e], r = [e[0], e[e.length - 1],], a = null; for (; ;) { if (n.every(e => !e || e === document.body || !e.parentElement)) return null; let l = n.map(e => e.parentElement).filter(Boolean), o = new Set(l.map(e => e.parentElement)), i = Array.from(o).find(e => r.every(t => e.contains(t))); if (i) { a = i; let s = null; t > 1 ? s = l.map(e => { for (; e && e.parentElement !== a;)e = e.parentElement; return e }) : (s = [i], a = "FIELDSET" === i.parentElement.tagName ? i.parentElement.parentElement : i.parentElement); let u = new Set(s); if (u.size < t) { console.warn({ Control_Function: "createVariantPicker()", message: "option_wrappers merged, resolving...", leafSelectors: e }); a = Array.from(u).find(e => r.every(t => e.contains(t))); s = [...e].map(e => { for (; e.parentElement !== a;)e = e.parentElement; return e }) } return { variantPicker: a, option_wrappers: s, LCA: i } } n = l } } function createLeafNodeSelectorSets(e, t, n) { let r = []; return t.forEach(t => { let a = [], l = new Set; e.forEach(e => { if (Object.hasOwn(e, t) && e[t].length) { if (1 === e[t].length || 1 === n) a.push(e[t][0]), l.add(0); else { let r = e[t].findIndex((e, t) => !l.has(t)); l.add(r), a.push(e[t][r]) } } }), r.push(a) }), console.log({ variantPickerKeySets: r }), r } function isPureLeaf(e, t) { let n = ["fieldset", "ul"]; if (!isElementVisible(e.parentElement)) return !1; let r = e.tagName.toLowerCase(); if (n.includes(r)) return !1; for (let a of n) if (e.querySelector(a)) return !1; return !0 } function makeOVAKeysForOptionAxes(e, t, n) { let r = n, a = new Set, l = []; return t.forEach((t, n) => { let o = { A1__optionValue: t, index: n }; r.forEach(n => { let r = `[${n}="${CSS.escape(t)}"]`, l = Array.from(e.querySelectorAll(r)); l.length && (l = l.filter(e => isPureLeaf(e, r)), Object.hasOwn(o, n) || (a.add(n), o[n] = []), o[n].push(...l)) }), a.size && (r = Array.from(a)), a.clear(), l.push(o) }), console.log({ ovaKeyForOptionAxes: l }), { selectorKeys: l, reduced_ova_array: r } } function selectorEncodingValidator(e, t, n, r = null) { let a = -1, l = n.length; outerLoop: for (let o of t) for (let i = 0; i < l; i++) { let s = `[${o}="${CSS.escape(n[i])}"]`, u = e.querySelector(s); if (u) { console.log({ ova: o, selectorFound: u, attributeSelector: s, encodingFormat: 0 }), a += 1; break outerLoop } } if (!r) return a; outerLoop: for (let c of t) for (let p = 0; p < l; p++) { let d = `[${c}="${CSS.escape(r[p])}"]`, f = e.querySelector(d); if (f) { console.log({ ova: c, selectorFound: f, attributeSelector: d, encodingFormat: 1 }), a += 2; break outerLoop } } return a } function getVariantPickerSets(e, t, n, r, a, l) { console.log({ optionValueRackSelected: t }); let { selectorKeys: o, reduced_ova_array: i } = makeOVAKeysForOptionAxes(e, t, n), s = o.filter(e => i.some(t => Object.hasOwn(e, t))), u = l.options.map((e, t) => t); if (a > 1 && s.length != a) { console.warn({ Control_Function: "Not all fieldsets are present", Pivot: "Remaking the selectorKeys for the populated Option Axes...", populatedSelectorKeys: s }), 1 === (u = s.map(e => e.index)).length ? (t = l.options[u[0]].values[r], a = 1) : (t = u.map(e => l.options[e].values[r].at(-1)), a = u.length); let c = makeOVAKeysForOptionAxes(e, t, i); ({ selectorKeys: o, reduced_ova_array: i } = c) } let p = createLeafNodeSelectorSets(o, i, a).map(e => createVariantPicker(e, a)).filter(Boolean); return p.length && i.length !== n.length ? [...p.map(e => ({ variant_picker: e, encodingIndex: r, OPTION_VALUE_ATTRIBUTES: i, optionCount: a, optionValueRack: t, matchedAxisIndices: u }))] : (console.warn({ Control_Function: "getVariantPickerSets", Failure: "could not extract the variant picker" }), null) } function getVariantPickersByRevCon(e, t) { let n = ["value", "data-option-value", "data-option-value-id", "data-option-id", "data-value", "data-value-id", "data-variant-id", "data-variant", "data-selected-value", "value-id", "data-value-handle", "data-option-handle", "data-handle", "data-option-key", "data-key", "data-option", "data-option-index", "data-index", "data-name", "data-current-value", "orig-value", "aria-label", "aria-valuetext", "data-swatch-option"], r = t.options.length, a = [0, 1].map(e => { if (t.options[0].values.length > e) return t.options.length > 1 ? t.options.map(t => t.values[e].at(-1)) : t.options[0].values[e] }).filter(Boolean); console.log({ optionValueRackCollection: a }); let l = null; if (-1 === (l = a.length > 1 ? selectorEncodingValidator(e, n, a[0], a[1]) : selectorEncodingValidator(e, n, a[0]))) return console.error({ Control_Function: "getVariantPickersByRevCon()", Failure: "Encoding format failure" }), null; console.log({ encodingIndex: l }); let o = []; return (o = 2 !== l ? getVariantPickerSets(e, a[l], n, l, r, t) || [] : a.map((a, l) => getVariantPickerSets(e, a, n, l, r, t)) || []).length ? o : (console.warn({ Control_Function: "getVariantPickersByRevCon()", Failure: "could not extract the variant picker" }), null) } function runTA7(e) { let t = { A__finalVariantPicker: null, B__parentNodeForVPCSearch: null, C__anchorData: null, D__variantPickerGenData: null }, n = { Variant_Picker: null, Full_Data: t, status: "failure" }, r = e => (console.error({ status: "[TA7] Failed", cause: e }), n), a = findAnchorProductForm(), { anchorProductForm: l, nameIdAnchors: o, validNameIdElement: i } = a; if (!l && !o.length) return r("variantID anchorForm not found"); t.C__anchorData = { nameIdElement: i, anchorProductForm: l, nameIdAnchors: o }; let s = null, u = (s = { options: e.options_with_values.map(e => ({ name: e.name, values: [e.values.map(e => e.name), e.values.map(e => e.id),] })) }).options.length, c = l || o.find(e => isElementVisible(e.parentElement)), p = c === l ? getParentNodeForVPCSearch(c, null, !1) : getParentNodeForVPCSearch(c, 5, !1); t.B__parentNodeForVPCSearch = { searchNode: p.parent, parentFoundInAnchorMode: !0 }; let d = getVariantPickersByRevCon(p.parent, s)?.flat().filter(Boolean); if (!d?.length) return r("No variant picker candidates found"); t.D__variantPickerGenData = d; let f = null; for (let m of d) { let g = isValidVariantPicker(m.variant_picker, m.optionCount, m.optionValueRack, m.OPTION_VALUE_ATTRIBUTES); if (!g) continue; let h = getCorrectVariantPickerWithSelectors(m.variant_picker, m.optionCount, m.optionValueRack, m.encodingIndex, s.options, g); if (h) { f = { variantPicker: m.variant_picker.variantPicker, option_wrappers: m.variant_picker.option_wrappers, selectors: h.selector_data, encodingIndex: m.encodingIndex, matchedAxisIndices: m.matchedAxisIndices }; break } } if (!f) return r("Final variant picker could not be resolved"); window.CAMOUFLAGEE && (f.camouflage_selectors = window.CAMOUFLAGEE.items[0].selectors); let v = { field_selector: null, selectors: [], selector_type: null, make_a_selection_required: null, value_attribute: null }, k = Array(u).fill(null).map(() => ({ ...v })); f.option_wrappers.forEach((e, t) => { let n = f.selectors[t].selectors[0], r = n.tagName.toLowerCase(), a = "option" === r ? "select" : r, l = { field_selector: e, selectors: "select" === a ? n.parentElement : f.selectors[t].selectors, selector_type: a, make_a_selection_required: "select" === a && !n.parentElement.options[0].value, value_attribute: f.selectors[t].value_attribute }; k[f.matchedAxisIndices[t]] = l }); let P = new Set(k.map(e => e.value_attribute)), V; return V = P.size > 1 ? Array.from(P) : P.values().next().value, t.A__finalVariantPicker = { variantPicker: f.variantPicker, encodingIndex: f.encodingIndex, option_wrappers_with_selectors: k, make_a_selection_required: k.some(e => e.make_a_selection_required), attribute_name: V, variantIdField: i, observer_container_node: p.parent, addToCartButton: p.addToCartButton, z__camouflage_selectors: f.camouflage_selectors || "Camouflage not enabled on store" }, n.Variant_Picker = t.A__finalVariantPicker, n.status = "success", console.log({ "[TA7 VERDICT]": "Success", TA7_Result: n }), n } module.exports = runTA7;